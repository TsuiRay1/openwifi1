/* Automatically generated by p4c-wp4 from test_wp4.p4 on Sun Jan 31 15:27:13 2021
 */
#include <linux/module.h>    // included for all kernel modules
#include <linux/kernel.h>    // included for KERN_INFO
#include <linux/init.h>      // included for __init and __exit macros
#include <linux/fs.h>
#include <linux/debugfs.h>
#include <linux/slab.h>
#include <linux/mm.h>
#include <linux/skbuff.h>
#include <linux/netdevice.h>
#include "wp4_runtime.h"


#include "wp4-p4.h"

#define WP4_MASK(t, w) ((((t)(1)) << (w)) - (t)1)
#define BYTES(w) ((w) / 8)

static int __init wp4_init(void) {
   printk(KERN_INFO "WP4: Loading WP4 LKM!\n");
   return 0;
}

static void __exit wp4_exit(void) {
   printk(KERN_INFO "WP4: Removing WP4 LKM!\n");
}

int wp4_packet_in(u8 *p_uc_data, u16 wp4_ul_size, u8 port){

    struct Headers_t headers = {
        .rfFeatures = {
            .wp4_valid = 0
        },
        .frameCtrl = {
            .wp4_valid = 0
        },
        .mac80211 = {
            .wp4_valid = 0
        },
    };

    u16 wp4_packetOffsetInBits = 0;
    u8 *wp4_packetStart = p_uc_data;
    struct wp4_output wp4out;
    struct wp4_input wp4in;
    wp4in.input_port = port;

    goto start;

// Start of Parser
    start: {
/* extract(headers.rfFeatures)*/
        if ((wp4_ul_size * 8) < 256) {
            
            goto accept;
        }
        memcpy(&headers.rfFeatures.timestamp, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(64));
        headers.rfFeatures.timestamp = htonll(headers.rfFeatures.timestamp);
        wp4_packetOffsetInBits += 64;

        memcpy(&headers.rfFeatures.rssi, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(16));
        headers.rfFeatures.rssi = htons(headers.rfFeatures.rssi);
        wp4_packetOffsetInBits += 16;

        memcpy(&headers.rfFeatures.blank, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(16));
        headers.rfFeatures.blank = htons(headers.rfFeatures.blank);
        wp4_packetOffsetInBits += 16;

        memcpy(&headers.rfFeatures.len, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(16));
        headers.rfFeatures.len = htons(headers.rfFeatures.len);
        wp4_packetOffsetInBits += 16;

        memcpy(&headers.rfFeatures.rate_idx, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(16));
        headers.rfFeatures.rate_idx = htons(headers.rfFeatures.rate_idx);
        wp4_packetOffsetInBits += 16;

        memcpy(&headers.rfFeatures.aux_1, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(32));
        headers.rfFeatures.aux_1 = htonl(headers.rfFeatures.aux_1);
        wp4_packetOffsetInBits += 32;

        memcpy(&headers.rfFeatures.freqOffset, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(32));
        headers.rfFeatures.freqOffset = htonl(headers.rfFeatures.freqOffset);
        wp4_packetOffsetInBits += 32;

        memcpy(&headers.rfFeatures.aux_3, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(32));
        headers.rfFeatures.aux_3 = htonl(headers.rfFeatures.aux_3);
        wp4_packetOffsetInBits += 32;

        memcpy(&headers.rfFeatures.aux_4, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(32));
        headers.rfFeatures.aux_4 = htonl(headers.rfFeatures.aux_4);
        wp4_packetOffsetInBits += 32;

        headers.rfFeatures.wp4_valid = 1;
        switch (headers.rfFeatures.aux_1) {
            case 0xccccdddd: goto mac;
            default: goto accept;
        }
    }
    mac: {
/* extract(headers.frameCtrl)*/
        if ((wp4_ul_size * 8) < 16) {
            
            goto accept;
        }
        memcpy(&headers.frameCtrl.protoVer, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(8));
        headers.frameCtrl.protoVer >>= 6;
        headers.frameCtrl.protoVer &= WP4_MASK(u8, 2);
        wp4_packetOffsetInBits += 2;

        memcpy(&headers.frameCtrl.frameType, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(8));
        headers.frameCtrl.frameType >>= 4;
        headers.frameCtrl.frameType &= WP4_MASK(u8, 2);
        wp4_packetOffsetInBits += 2;

        memcpy(&headers.frameCtrl.subType, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(8));
        headers.frameCtrl.subType &= WP4_MASK(u8, 4);
        wp4_packetOffsetInBits += 4;

        memcpy(&headers.frameCtrl.toDS, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(8));
        headers.frameCtrl.toDS >>= 7;
        headers.frameCtrl.toDS &= WP4_MASK(u8, 1);
        wp4_packetOffsetInBits += 1;

        memcpy(&headers.frameCtrl.fromDS, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(8));
        headers.frameCtrl.fromDS >>= 6;
        headers.frameCtrl.fromDS &= WP4_MASK(u8, 1);
        wp4_packetOffsetInBits += 1;

        memcpy(&headers.frameCtrl.moreFrag, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(8));
        headers.frameCtrl.moreFrag >>= 5;
        headers.frameCtrl.moreFrag &= WP4_MASK(u8, 1);
        wp4_packetOffsetInBits += 1;

        memcpy(&headers.frameCtrl.retry, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(8));
        headers.frameCtrl.retry >>= 4;
        headers.frameCtrl.retry &= WP4_MASK(u8, 1);
        wp4_packetOffsetInBits += 1;

        memcpy(&headers.frameCtrl.pwrMgmt, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(8));
        headers.frameCtrl.pwrMgmt >>= 3;
        headers.frameCtrl.pwrMgmt &= WP4_MASK(u8, 1);
        wp4_packetOffsetInBits += 1;

        memcpy(&headers.frameCtrl.moreData, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(8));
        headers.frameCtrl.moreData >>= 2;
        headers.frameCtrl.moreData &= WP4_MASK(u8, 1);
        wp4_packetOffsetInBits += 1;

        memcpy(&headers.frameCtrl.protFrame, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(8));
        headers.frameCtrl.protFrame >>= 1;
        headers.frameCtrl.protFrame &= WP4_MASK(u8, 1);
        wp4_packetOffsetInBits += 1;

        memcpy(&headers.frameCtrl.order, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(8));
        headers.frameCtrl.order &= WP4_MASK(u8, 1);
        wp4_packetOffsetInBits += 1;

        headers.frameCtrl.wp4_valid = 1;
        switch (headers.frameCtrl.frameType) {
            case 0x0: goto mgnt;
            default: goto accept;
        }
    }
    mgnt: {
/* extract(headers.mac80211)*/
        if ((wp4_ul_size * 8) < 224) {
            
            goto accept;
        }
        memcpy(&headers.mac80211.durID, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(16));
        headers.mac80211.durID = htons(headers.mac80211.durID);
        wp4_packetOffsetInBits += 16;

        memcpy(&headers.mac80211.Addr1, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(64));
        headers.mac80211.Addr1 = htonll(headers.mac80211.Addr1) >> 16;
        headers.mac80211.Addr1 &= WP4_MASK(u64, 48);
        wp4_packetOffsetInBits += 48;

        memcpy(&headers.mac80211.Addr2, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(64));
        headers.mac80211.Addr2 = htonll(headers.mac80211.Addr2) >> 16;
        headers.mac80211.Addr2 &= WP4_MASK(u64, 48);
        wp4_packetOffsetInBits += 48;

        memcpy(&headers.mac80211.Addr3, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(64));
        headers.mac80211.Addr3 = htonll(headers.mac80211.Addr3) >> 16;
        headers.mac80211.Addr3 &= WP4_MASK(u64, 48);
        wp4_packetOffsetInBits += 48;

        memcpy(&headers.mac80211.seqCtrl, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(16));
        headers.mac80211.seqCtrl = htons(headers.mac80211.seqCtrl);
        wp4_packetOffsetInBits += 16;

        memcpy(&headers.mac80211.Addr4, wp4_packetStart + BYTES(wp4_packetOffsetInBits), BYTES(64));
        headers.mac80211.Addr4 = htonll(headers.mac80211.Addr4) >> 16;
        headers.mac80211.Addr4 &= WP4_MASK(u64, 48);
        wp4_packetOffsetInBits += 48;

        headers.mac80211.wp4_valid = 1;
        goto accept;
    }

    reject: { return 1; }


// Start of Pipeline
    accept:
    {
        u8 hit;
        {
/* test_tbl_0.apply()*/
            {
                /* construct key */
                struct swtch_test_tbl_key key = {};
                key.field0 = headers.frameCtrl.frameType;
                /* value */
                struct swtch_test_tbl_value *value = NULL;
                /* perform lookup */
                wp4_table_lookup(&swtch_test_tbl, &key);
                if (value == NULL) {
                    /* miss; find default action */
                    hit = 0;
                    wp4_table_lookup(&swtch_test_tbl_defaultAction, &wp4_zero);
                } else {
                    hit = 1;
                }
                if (value != NULL) {
                    /* run action */
                    switch (value->action) {
                        case swtch_mod_nw_tos: 
                        {
wp4out.output_port = 32w1;
                        }
                        break;
                        case _NoAction: 
                        {
                        }
                        break;
                        default: return 1;
                    }
                }
                else return 1;
            }
;
        }
    }

// Start of Deparser
    
    return 0;
}

// Kernel module functions
EXPORT_SYMBOL(wp4_packet_in);

module_init(wp4_init);
module_exit(wp4_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("test_wp4.p4");
MODULE_DESCRIPTION("WP4");
MODULE_VERSION("0.1");

